import { z } from "zod";
import { Decimal } from "decimal.js";
import { areIntervalsOverlapping, parse, addDays, isEqual } from "date-fns";

export const DecimalSchema = z
  .string()
  .or(z.number())
  .transform((val) => new Decimal(val))
  .refine((val) => !val.isNaN(), { message: "Invalid decimal value" });

export const PositiveDecimal = DecimalSchema.refine((v) => v.gt(0), {
  message: "Must be greater than 0",
});

export const NonNegativeDecimal = DecimalSchema.refine((v) => v.gte(0), {
  message: "Must be greater than or equal to 0",
});

export const NegativeDecimal = DecimalSchema.refine((v) => v.lt(0), {
  message: "Must be less than 0",
});

export const InstrumentStatusSchema = z.enum([
  "active",
  "inactive",
  "delisted",
  "halted",
]);

export const InstrumentTypeSchema = z.enum([
  "spot",
  "futures",
  "options",
  "other",
]);

export const InstrumentMarginTypeSchema = z.enum(["cross", "isolated"]);

export const InstrumentMarketSchema = z.enum([
  "crypto",
  "stocks",
  "forex",
  "futures",
  "options",
  "indices",
  "commodities",
  "bonds",
  "etfs",
  "cfds",
  "funds",
  "rates",
  "synthetic",
  "other",
]);

const ISO_3166_1_ALPHA_2 = /^[A-Z]{2}$/;

export const SettlementDelaySchema = z.enum(["T+0", "T+1", "T+2"]);

export type InstrumentStatus = z.infer<typeof InstrumentStatusSchema>;
export type InstrumentType = z.infer<typeof InstrumentTypeSchema>;
export type InstrumentMarginType = z.infer<typeof InstrumentMarginTypeSchema>;
export type InstrumentMarket = z.infer<typeof InstrumentMarketSchema>;
export type SettlementDelay = z.infer<typeof SettlementDelaySchema>;

// Supports split-day trading (e.g., 09:00-12:00 and 13:00-16:00)
export const TradingHoursSchema = z.object({
  days: z
    .array(z.number().int().min(0).max(6))
    .min(1)
    .refine((arr) => new Set(arr).size === arr.length, {
      message: "Days cannot contain duplicates",
    }),
  sessions: z
    .array(
      z.object({
        open: z.string().regex(/^([0-1]\d|2[0-3]):[0-5]\d$/),
        close: z.string().regex(/^([0-1]\d|2[0-3]):[0-5]\d$/),
      })
    )
    .min(1),
});

export type TradingHours = z.infer<typeof TradingHoursSchema>;

/**
 * Circuit Breaker using percentage-based limits
 * Example: upperLimitPercent: 0.10 means +10% from reference price
 *          lowerLimitPercent: -0.10 means -10% from reference price
 */
export const CircuitBreakerSchema = z.object({
  upperLimitPercent: z
    .number()
    .positive()
    .max(1, "Upper limit cannot exceed 100%"),
  lowerLimitPercent: z
    .number()
    .negative()
    .min(-1, "Lower limit cannot be less than -100%"),
  duration: z
    .number()
    .int()
    .positive()
    .max(86400, "Duration cannot exceed 24 hours (86400 seconds)"),
});

export type CircuitBreaker = z.infer<typeof CircuitBreakerSchema>;

export const ExtendedHoursSchema = z.object({
  /** Pre-market trading hours */
  preMarket: TradingHoursSchema,
  /** After-hours trading hours */
  afterHours: TradingHoursSchema,
});

export type ExtendedHours = z.infer<typeof ExtendedHoursSchema>;

export const OrderTypeSchema = z.enum([
  "market",
  "limit",
  "stop",
  "stop_limit",
]);

export type OrderType = z.infer<typeof OrderTypeSchema>;

// ============================================
// INSTRUMENT SCHEMA
// ============================================

export const InstrumentSchema = z
  .object({
    /**
     * Database primary key.
     * UUID v7 generated by Postgres.
     * Immutable.
     */
    id: z.string().uuid(),

    /**
     * Internal business identifier.
     * Stable across systems (DB, search, cache, logs).
     * Example: "binance-btc-usdt"
     */
    internalId: z.string().min(1),

    /**
     * Idempotent identifier used by search engines (Typesense, Meilisearch).
     * Must be deterministic and unique.
     */
    idempotentId: z.string().min(1),

    /**
     * Trading symbol as defined by the venue or market.
     * Examples: "BTCUSDT", "AAPL", "EURUSD"
     */
    symbol: z.string().min(1),

    /**
     * Human-friendly symbol for UI display.
     * Example: "BTC/USDT"
     */
    symbolDisplay: z.string().min(1),

    /**
     * Descriptive instrument name.
     * Example: "Bitcoin / Tether USD"
     */
    description: z.string().min(1),

    /**
     * Base asset of the instrument.
     * What is being bought or sold.
     * Example: "BTC"
     */
    base: z.string().min(1),

    /**
     * Quote asset of the instrument.
     * What the price is denominated in.
     * Example: "USDT"
     */
    quote: z.string().min(1),

    /**
     * Exchange, broker, or venue name.
     * Example: "Binance", "NASDAQ", "CME"
     */
    exchange: z.string().min(1),

    /**
     * Country or jurisdiction where the exchange operates.
     * Example: "US", "JP", "SG"
     */
    exchangeCountry: z.string().regex(ISO_3166_1_ALPHA_2),

    /**
     * Market category.
     * Examples: "crypto", "stocks", "forex", "futures"
     */
    market: InstrumentMarketSchema,

    /**
     * Instrument type.
     * Examples: "spot", "futures", "options", "other"
     */
    type: InstrumentTypeSchema,

    /**
     * Name of the data or execution provider.
     * Example: "Binance", "Bloomberg", "InteractiveBrokers"
     */
    providerName: z.string().min(1),

    /**
     * Provider-specific instrument identifier.
     * Unique within the provider.
     */
    providerId: z.string().min(1),

    /**
     * Provider-specific trading symbol.
     */
    providerSymbol: z.string().min(1),

    /**
     * Instrument lifecycle status.
     * Examples: "active", "inactive", "delisted"
     */
    status: InstrumentStatusSchema,

    /**
     * Whether the instrument is hidden from search and UI.
     */
    isHidden: z.boolean(),

    /**
     * Indicates synthetic or derived instruments
     * (indexes, baskets, internal products).
     */
    isSynthetic: z.boolean(),

    /**
     * International Securities Identification Number (if applicable).
     */
    isin: z.string().optional(),

    /**
     * Committee on Uniform Securities Identification Procedures code.
     */
    cusip: z.string().optional(),

    /**
     * Minimum allowed price increment.
     * Prices must be multiples of this value.
     */
    tickSize: PositiveDecimal,

    /**
     * Quantity step size.
     * Defines the minimum increment for quantity.
     * Mutually exclusive with lotSize.
     */
    stepSize: PositiveDecimal.optional(),

    /**
     * Maximum number of decimal places allowed in price.
     * Must be consistent with tickSize.
     *
     * pricePrecision === decimals(tickSize)
     */
    pricePrecision: z.number().int().nonnegative(),

    /**
     * Maximum number of decimal places allowed in quantity.
     * Only valid when stepSize is used.
     */
    quantityPrecision: z.number().int().nonnegative().optional(),

    /**
     * Minimum quantity allowed per order.
     */
    minQuantity: PositiveDecimal,

    /**
     * Maximum quantity allowed per order.
     */
    maxQuantity: PositiveDecimal,

    /**
     * Minimum notional value required to place an order.
     * HARD CONSTRAINT — orders below this value MUST be rejected.
     * notional = price × quantity
     * Must be greater than 0.
     */
    minOrderValue: PositiveDecimal,

    /**
     * Maximum notional value allowed per order.
     * HARD CONSTRAINT — orders above this value MUST be rejected.
     * notional = price × quantity
     * Must be greater than 0.
     */
    maxOrderValue: PositiveDecimal,

    /**
     * Fixed lot size for instruments traded in whole lots.
     * Mutually exclusive with stepSize and quantityPrecision.
     */
    lotSize: PositiveDecimal.optional(),

    /**
     * Contract size for derivatives.
     * Represents how much underlying one contract controls.
     */
    contractSize: z.number().positive().optional(),

    /**
     * Contract size unit (e.g., "shares", "barrels", "ounces").
     * Required if contractSize is specified.
     */
    contractSizeUnit: z.string().optional(),

    /**
     * Number of decimals used for UI display only.
     * Does NOT affect order validation.
     */
    displayDecimals: z.number().int().nonnegative(),

    /**
     * Default leverage shown in UI.
     * Only valid if leverageMax exists.
     * Must be >= 1.0 (cannot be less than 1x leverage).
     */
    leverage: z.number().min(1, "Leverage must be at least 1x").optional(),

    /**
     * Maximum leverage allowed by the venue.
     * If undefined, leverage is not supported.
     * Must be >= 1.0.
     */
    leverageMax: z
      .number()
      .min(1, "Max leverage must be at least 1x")
      .optional(),

    /**
     * Supported margin types for this instrument.
     * Examples: ["cross", "isolated"]
     */
    supportedMarginTypes: z.array(InstrumentMarginTypeSchema).min(1),

    /**
     * Initial margin requirement (as a fraction, e.g., 0.10 = 10%).
     * Must be between 0 and 1.
     */
    initialMargin: z
      .number()
      .nonnegative()
      .max(1, "Initial margin cannot exceed 100%")
      .optional(),

    /**
     * Maintenance margin requirement (as a fraction, e.g., 0.05 = 5%).
     * Must be between 0 and 1.
     */
    maintenanceMargin: z
      .number()
      .nonnegative()
      .max(1, "Maintenance margin cannot exceed 100%")
      .optional(),

    /**
     * Expiration date for expiring derivatives.
     * ISO-8601 format.
     */
    expiryDate: z.string().datetime().optional(),

    /**
     * Settlement method for derivatives.
     * Examples: "cash", "physical"
     */
    settlementType: z.string().optional(),

    /**
     * Settlement delay after trade execution.
     * Examples: "T+0", "T+1", "T+2"
     */
    settlementDelay: SettlementDelaySchema.optional(),

    /**
     * Price multiplier applied for display or settlement.
     */
    priceMultiplier: z.number().positive().optional(),

    /**
     * Currency used for pricing the instrument.
     */
    pricingCurrency: z.string().optional(),

    /**
     * Underlying asset for derivatives.
     */
    underlyingAsset: z.string().optional(),

    /**
     * Currency used for settlement.
     */
    settlementCurrency: z.string().optional(),

    /**
     * Trading hours for non-24/7 markets.
     */
    tradingHours: TradingHoursSchema.optional(),

    /**
     * Extended trading hours (pre-market and after-hours).
     */
    extendedHours: ExtendedHoursSchema.optional(),

    /**
     * Circuit breaker configuration to prevent extreme price movements.
     */
    circuitBreaker: CircuitBreakerSchema.optional(),

    /**
     * Supported order types for this instrument.
     */
    supportedOrderTypes: z.array(OrderTypeSchema).min(1),

    /**
     * Tags for categorization and filtering.
     */
    tags: z.array(z.string()),

    /**
     * Priority for UI ranking and sorting.
     * Should be between 0 and 1000 for reasonable UI sorting.
     */
    priority: z.number().int().min(0).max(1000).optional(),

    /**
     * Icon URL used in UI.
     */
    iconUrl: z.string(),

    /**
     * Highlight color for UI theming.
     */
    highlightColor: z
      .string()
      .regex(
        /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
        "Must be a valid hex color (e.g., #FF5733 or #F53)"
      ),

    /**
     * Alternative symbols or aliases.
     */
    symbol_aliases: z.array(z.string()),

    /**
     * Precomputed full-text search string.
     * symbol + symbolDisplay + description + aliases
     * Required for search functionality.
     */
    fullTextSearch: z.string().min(1),

    /**
     * User Fee tier plan.
     */
    feeTier: z.string().optional(),

    /**
     * Maker fee percentage (as decimal, e.g., 0.001 = 0.1%).
     * Cannot exceed 100% (1.0).
     */
    makerFee: NonNegativeDecimal.refine((v) => v.lte(1), {
      message: "Maker fee cannot exceed 100%",
    }),

    /**
     * Taker fee percentage (as decimal, e.g., 0.001 = 0.1%).
     * Cannot exceed 100% (1.0).
     */
    takerFee: NonNegativeDecimal.refine((v) => v.lte(1), {
      message: "Taker fee cannot exceed 100%",
    }),

    /**
     * Typical bid-ask spread for informational purposes.
     * MUST NOT be used for execution.
     */
    typicalSpread: z.number().nonnegative().optional(),

    /**
     * Indicates whether the instrument is tradable.
     */
    isTradable: z.boolean(),

    /**
     * Indicates whether KYC is required to trade.
     */
    requiresKYC: z.boolean(),

    /**
     * Indicates support for futures trading.
     */
    supportsFutures: z.boolean().optional(),

    /**
     * Regulatory framework applicable to the instrument.
     */
    regulation: z.string().optional(),

    /**
     * Timezone used for trading hours and sessions.
     * Must be a valid IANA timezone.
     */
    timezone: z.string().refine(
      (tz) => {
        try {
          Intl.DateTimeFormat(undefined, { timeZone: tz });
          return true;
        } catch {
          return false;
        }
      },
      {
        message:
          "Must be a valid IANA timezone (e.g., 'America/New_York', 'UTC', 'Europe/London')",
      }
    ),

    /**
     * Creation UNIX ms timestamp.
     */
    createdAt: z.number().int().nonnegative(),

    /**
     * Last update UNIX ms timestamp.
     */
    updatedAt: z.number().int().nonnegative(),

    /**
     * Lowercase symbol optimized for autocomplete.
     * Automatically derived from symbol.
     */
    symbol_lc: z.string(),

    /**
     * Additional search terms for discovery.
     */
    search_terms: z.array(z.string()).optional(),

    /**
     * Supported timeframes (5m, 1h, 4h, 1d, etc)
     */
    supportedTimeframes: z.array(z.string()).min(1),

    /**
     * Supports OHLCV
     */
    supportsOHLCV: z.boolean(),

    /**
     * Countries where this instrument cannot be traded.
     * Must be valid ISO 3166-1 alpha-2 codes.
     */
    restrictedCountries: z.array(z.string().regex(ISO_3166_1_ALPHA_2)),
  })
  .superRefine((data, ctx) => {
    // ============================================
    // 1. LEVERAGE CONSISTENCY
    // ============================================
    if (data.leverage !== undefined && data.leverageMax === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "leverageMax required if leverage is set",
        path: ["leverage"],
      });
    }
    if (data.leverage && data.leverageMax && data.leverage > data.leverageMax) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "leverage cannot exceed leverageMax",
        path: ["leverage"],
      });
    }

    // ============================================
    // 2. MARGIN CONSISTENCY
    // ============================================
    if (
      data.initialMargin !== undefined &&
      data.maintenanceMargin !== undefined &&
      data.initialMargin < data.maintenanceMargin
    ) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "initialMargin must be >= maintenanceMargin",
        path: ["initialMargin"],
      });
    }

    // ============================================
    // 3. TIMEZONE DEPENDENCY
    // ============================================
    if ((data.tradingHours || data.extendedHours) && !data.timezone) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "timezone required when tradingHours or extendedHours is set",
        path: ["timezone"],
      });
    }

    if (data.displayDecimals < data.pricePrecision) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          "displayDecimals should be >= pricePrecision for accurate display",
        path: ["displayDecimals"],
      });
    }

    // ============================================
    // 4. PRICE PRECISION VALIDATION
    // ============================================
    if (data.pricePrecision !== data.tickSize.decimalPlaces()) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "pricePrecision must match tickSize decimal places",
        path: ["pricePrecision"],
      });
    }

    if (data.minQuantity.gte(data.maxQuantity)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "minQuantity must be < maxQuantity",
        path: ["minQuantity"],
      });
    }

    // ============================================
    // 5. QUANTITY MODEL (STEP VS LOT)
    // ============================================
    const { stepSize, lotSize, quantityPrecision, minQuantity, maxQuantity } =
      data;

    // Mutual exclusivity
    if (stepSize && lotSize) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Cannot use both stepSize and lotSize (mutually exclusive)",
        path: ["stepSize"],
      });
    }

    // CONTINUOUS MODEL (stepSize)
    if (stepSize) {
      if (quantityPrecision === undefined) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "quantityPrecision required when stepSize is set",
          path: ["quantityPrecision"],
        });
      } else if (quantityPrecision !== stepSize.decimalPlaces()) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "quantityPrecision must match stepSize decimal places",
          path: ["quantityPrecision"],
        });
      }
      if (!minQuantity.mod(stepSize).isZero()) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "minQuantity must be a multiple of stepSize",
          path: ["minQuantity"],
        });
      }
      if (!maxQuantity.mod(stepSize).isZero()) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "maxQuantity must be a multiple of stepSize",
          path: ["maxQuantity"],
        });
      }
    }

    // DISCRETE MODEL (lotSize)
    if (lotSize) {
      if (quantityPrecision !== undefined) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "quantityPrecision cannot be set when using lotSize",
          path: ["quantityPrecision"],
        });
      }
      if (!minQuantity.mod(lotSize).isZero()) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "minQuantity must be a multiple of lotSize",
          path: ["minQuantity"],
        });
      }
      if (!maxQuantity.mod(lotSize).isZero()) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "maxQuantity must be a multiple of lotSize",
          path: ["maxQuantity"],
        });
      }
    }

    // ORPHANED quantityPrecision (neither stepSize nor lotSize)
    // FIXED: Only stepSize allows quantityPrecision
    if (!stepSize && !lotSize && quantityPrecision !== undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "quantityPrecision requires stepSize to be defined",
        path: ["quantityPrecision"],
      });
    }

    // ============================================
    // 6. ORDER VALUE VALIDATION
    // ============================================
    if (data.minOrderValue.gte(data.maxOrderValue)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "minOrderValue must be < maxOrderValue",
        path: ["minOrderValue"],
      });
    }

    // ============================================
    // 7. CONTRACT SIZE UNIT VALIDATION
    // ============================================
    if (data.contractSize && !data.contractSizeUnit) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "contractSizeUnit required when contractSize is specified",
        path: ["contractSizeUnit"],
      });
    }

    // ============================================
    // 8. TRADING HOURS SESSION VALIDATION
    // ============================================
    if (data.tradingHours) {
      const sessionErrors = validateTradingSessions(data.tradingHours.sessions);
      sessionErrors.forEach((error) => {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: error.message,
          path: error.index !== undefined 
            ? ["tradingHours", "sessions", error.index]
            : ["tradingHours", "sessions"],
        });
      });
    }

    // ============================================
    // 9. SYMBOL_LC VALIDATION
    // ============================================
    if (data.symbol_lc !== data.symbol.toLowerCase()) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "symbol_lc must be the lowercase version of symbol",
        path: ["symbol_lc"],
      });
    }
  })
  .readonly();

export type Instrument = z.infer<typeof InstrumentSchema>;

/**
 * ============================================================
 * QUANTITY MODEL — LOGICAL MATRIX (UPDATED)
 * ============================================================
 *
 * This matrix defines the EXECUTION-VALID states for the instrument.
 * Any violation of these states is caught by the superRefine block.
 *
 * | stepSize | lotSize | qtyPrecision | Model / Validity                     |
 * |--------- |-------- |------------- |--------------------------------------|
 * | defined  | none    | defined      | ✅ Continuous (e.g. Crypto, Forex)   |
 * | defined  | none    | none         | ❌ INVALID – precision required      |
 * | none     | defined | none         | ✅ Discrete (e.g. Stocks, Options)   |
 * | none     | defined | defined      | ❌ INVALID – lots are discrete       |
 * | defined  | defined | any          | ❌ INVALID – mutually exclusive      |
 * | none     | none    | none         | ✅ Provider controlled (no validation)|
 * | none     | none    | defined      | ❌ INVALID – precision needs stepSize|
 *
 * ------------------------------------------------------------
 * HARD INVARIANTS (ENFORCED BY SCHEMA)
 * ------------------------------------------------------------
 *
 * 1. Mutual Exclusivity: (stepSize XOR lotSize)
 * - An instrument cannot be both continuous and discrete.
 *
 * 2. Precision Symmetry: (stepSize <==> quantityPrecision)
 * - quantityPrecision MUST exist if and only if stepSize exists.
 *
 * 3. Mathematical Consistency:
 * - quantityPrecision === decimals(stepSize)
 * - This ensures valid arithmetic for order rounding.
 *
 * 4. Incremental Alignment:
 * - minQuantity % increment == 0 (where increment is stepSize OR lotSize)
 * - maxQuantity % increment == 0
 *
 * 5. Margin Requirements:
 * - initialMargin >= maintenanceMargin (universal margin rule)
 *
 * 6. Leverage Consistency:
 * - leverage requires leverageMax to be defined
 * - leverage <= leverageMax
 * - Both must be >= 1.0 (minimum 1x leverage)
 *
 * 7. Fee Limits:
 * - makerFee and takerFee cannot exceed 100% (1.0)
 *
 * 8. Order Value Bounds:
 * - minOrderValue > 0 (cannot be zero)
 * - maxOrderValue > 0 (cannot be zero)
 * - minOrderValue < maxOrderValue (strict inequality)
 *
 * 9. Trading Hours:
 * - Close time cannot equal open time (zero-duration sessions not allowed)
 * - Sessions cannot overlap with each other
 * - Days cannot contain duplicates
 * - Requires timezone when tradingHours or extendedHours is set
 *
 * 10. Circuit Breaker:
 * - Uses percentage-based limits (not absolute values)
 * - upperLimitPercent: positive (e.g., 0.10 = +10%)
 * - lowerLimitPercent: negative (e.g., -0.10 = -10%)
 * - duration: maximum 24 hours (86400 seconds)
 *
 * 11. Contract Size:
 * - contractSizeUnit required when contractSize is specified
 *
 * 12. Timezone:
 * - Must be a valid IANA timezone identifier
 * - Validated using Intl.DateTimeFormat
 *
 * ------------------------------------------------------------
 * DOMAIN EXAMPLES
 * ------------------------------------------------------------
 * - Continuous: BTC/USDT (stepSize: 0.00001, precision: 5)
 * - Discrete:   AAPL Equity (lotSize: 1, precision: undefined)
 * - Derivative: SPY Option  (lotSize: 100, precision: undefined)
 * - Provider:   Custom Instrument (no stepSize/lotSize)
 * ============================================================
 */





function validateTradingSessions(
  sessions: Array<{ open: string; close: string }>
): Array<{ index?: number; message: string }> {
  const errors: Array<{ index?: number; message: string }> = [];
  const baseDate = new Date(2000, 0, 1);

  // Parsear y validar cada sesión
  const intervals = sessions.map((session, i) => {
    const start = parse(session.open, "HH:mm", baseDate);
    let end = parse(session.close, "HH:mm", baseDate);

    // ✅ CRÍTICO: Validar duración cero PRIMERO (antes de addDays)
    if (isEqual(start, end)) {
      errors.push({
        index: i,
        message: `Session ${i}: Close time cannot equal open time (${session.open})`
      });
    }

    // ✅ Usar < en vez de <= para overnight sessions
    // Esto previene que sesiones con duración cero se traten como overnight
    if (end < start) {
      end = addDays(end, 1);
    }

    return { start, end, index: i, session };
  });

  // Detectar overlaps usando areIntervalsOverlapping de date-fns
  for (let i = 0; i < intervals.length; i++) {
    for (let j = i + 1; j < intervals.length; j++) {
      const hasOverlap = areIntervalsOverlapping(
        { start: intervals[i].start, end: intervals[i].end },
        { start: intervals[j].start, end: intervals[j].end },
        { inclusive: false }
      );

      if (hasOverlap) {
        errors.push({
          message: `Sessions ${i} and ${j} overlap: [${intervals[i].session.open}-${intervals[i].session.close}] overlaps with [${intervals[j].session.open}-${intervals[j].session.close}]`
        });
      }
    }
  }

  return errors;
}