import { z } from "zod";
import { Decimal } from "decimal.js";

export const DecimalSchema = z
  .string()
  .or(z.number())
  .transform((val) => new Decimal(val))
  .refine((val) => !val.isNaN(), { message: "Invalid decimal value" });

export const PositiveDecimal = DecimalSchema.refine((v) => v.gt(0), {
  message: "Must be greater than 0",
});

export const NonNegativeDecimal = DecimalSchema.refine((v) => v.gte(0), {
  message: "Must be greater than or equal to 0",
});

export const InstrumentStatusSchema = z.enum([
  "active",
  "inactive",
  "delisted",
  "halted",
]);

export const InstrumentTypeSchema = z.enum([
  "spot",
  "futures",
  "options",
  "other",
]);

export const InstrumentMarginTypeSchema = z.enum(["cross", "isolated"]);

export const InstrumentMarketSchema = z.enum([
  "crypto",
  "stocks",
  "forex",
  "futures",
  "options",
  "indices",
  "commodities",
  "bonds",
  "etfs",
  "cfds",
  "funds",
  "rates",
  "synthetic",
  "other",
]);

const ISO_3166_1_ALPHA_2 = /^[A-Z]{2}$/;

export const SettlementDelaySchema = z.enum(["T+0", "T+1", "T+2"]);

export type InstrumentStatus = z.infer<typeof InstrumentStatusSchema>;
export type InstrumentType = z.infer<typeof InstrumentTypeSchema>;
export type InstrumentMarginType = z.infer<typeof InstrumentMarginTypeSchema>;
export type InstrumentMarket = z.infer<typeof InstrumentMarketSchema>;
export type SettlementDelay = z.infer<typeof SettlementDelaySchema>;

// Supports split-day trading (e.g., 09:00-12:00 and 13:00-16:00)
export const TradingHoursSchema = z.object({
  days: z.array(z.number().int().min(0).max(6)),
  sessions: z
    .array(
      z.object({
        open: z.string().regex(/^([0-1]\d|2[0-3]):[0-5]\d$/),
        close: z.string().regex(/^([0-1]\d|2[0-3]):[0-5]\d$/),
      })
    )
    .min(1),
});

export type TradingHours = z.infer<typeof TradingHoursSchema>;

// Prevents floating-point drift in price limit calculations
export const CircuitBreakerSchema = z.object({
  upperLimit: PositiveDecimal,
  lowerLimit: DecimalSchema.refine((v) => v.lt(0)),
  duration: z.number().int().positive(),
});

export type CircuitBreaker = z.infer<typeof CircuitBreakerSchema>;

export const ExtendedHoursSchema = z.object({
  /** Pre-market trading hours */
  preMarket: TradingHoursSchema,
  /** After-hours trading hours */
  afterHours: TradingHoursSchema,
});

export type ExtendedHours = z.infer<typeof ExtendedHoursSchema>;

export const OrderTypeSchema = z.enum([
  "market",
  "limit",
  "stop",
  "stop_limit",
]);

export type OrderType = z.infer<typeof OrderTypeSchema>;

// ============================================
// INSTRUMENT SCHEMA
// ============================================

export const InstrumentSchema = z
  .object({
    /**
     * Database primary key.
     * UUID v7 generated by Postgres.
     * Immutable.
     */
    id: z.string().uuid(),

    /**
     * Internal business identifier.
     * Stable across systems (DB, search, cache, logs).
     * Example: "binance-btc-usdt"
     */
    internalId: z.string().min(1),

    /**
     * Idempotent identifier used by search engines (Typesense, Meilisearch).
     * Must be deterministic and unique.
     */
    idempotentId: z.string().min(1),

    /**
     * Trading symbol as defined by the venue or market.
     * Examples: "BTCUSDT", "AAPL", "EURUSD"
     */
    symbol: z.string().min(1),

    /**
     * Human-friendly symbol for UI display.
     * Example: "BTC/USDT"
     */
    symbolDisplay: z.string().min(1),

    /**
     * Descriptive instrument name.
     * Example: "Bitcoin / Tether USD"
     */
    description: z.string().min(1),

    /**
     * Base asset of the instrument.
     * What is being bought or sold.
     * Example: "BTC"
     */
    base: z.string().min(1),

    /**
     * Quote asset of the instrument.
     * What the price is denominated in.
     * Example: "USDT"
     */
    quote: z.string().min(1),

    /**
     * Exchange, broker, or venue name.
     * Example: "Binance", "NASDAQ", "CME"
     */
    exchange: z.string().min(1),

    /**
     * Country or jurisdiction where the exchange operates.
     * Example: "US", "JP", "SG"
     */
    exchangeCountry: z.string().regex(ISO_3166_1_ALPHA_2),

    /**
     * Market category.
     * Examples: "crypto", "stocks", "forex", "futures"
     */
    market: InstrumentMarketSchema,

    /**
     * Instrument type.
     * Examples: "spot", "futures", "options", "other"
     */
    type: InstrumentTypeSchema,

    /**
     * Name of the data or execution provider.
     * Example: "Binance", "Bloomberg", "InteractiveBrokers"
     */
    providerName: z.string().min(1),

    /**
     * Provider-specific instrument identifier.
     * Unique within the provider.
     */
    providerId: z.string().min(1),

    /**
     * Provider-specific trading symbol.
     */
    providerSymbol: z.string().min(1),

    /**
     * Instrument lifecycle status.
     * Examples: "active", "inactive", "delisted"
     */
    status: InstrumentStatusSchema,

    /**
     * Whether the instrument is hidden from search and UI.
     */
    isHidden: z.boolean(),

    /**
     * Indicates synthetic or derived instruments
     * (indexes, baskets, internal products).
     */
    isSynthetic: z.boolean(),

    /**
     * International Securities Identification Number (if applicable).
     */
    isin: z.string().optional(),

    /**
     * Committee on Uniform Securities Identification Procedures code.
     */
    cusip: z.string().optional(),

    /**
     * Minimum allowed price increment.
     * Prices must be multiples of this value.
     */
    tickSize: PositiveDecimal,

    /**
     * Quantity step size.
     * Defines the minimum increment for quantity.
     * Mutually exclusive with lotSize.
     */
    stepSize: PositiveDecimal.optional(),

    /**
     * Maximum number of decimal places allowed in price.
     * Must be consistent with tickSize.
     *
     * pricePrecision === decimals(tickSize)
     */
    pricePrecision: z.number().int().nonnegative(),

    /**
     * Maximum number of decimal places allowed in quantity.
     * Only valid when stepSize is used.
     */
    quantityPrecision: z.number().int().nonnegative().optional(),

    /**
     * Minimum quantity allowed per order.
     */
    minQuantity: PositiveDecimal,

    /**
     * Maximum quantity allowed per order.
     */
    maxQuantity: PositiveDecimal,

    /**
     * Minimum notional value required to place an order.
     * HARD CONSTRAINT — orders below this value MUST be rejected.
     * notional = price × quantity
     */
    minOrderValue: NonNegativeDecimal,

    /**
     * Maximum notional value allowed per order.
     * HARD CONSTRAINT — orders above this value MUST be rejected.
     * notional = price × quantity
     */
    maxOrderValue: NonNegativeDecimal,

    /**
     * Fixed lot size for instruments traded in whole lots.
     * Mutually exclusive with stepSize and quantityPrecision.
     */
    lotSize: PositiveDecimal.optional(),

    /**
     * Contract size for derivatives.
     * Represents how much underlying one contract controls.
     */
    contractSize: z.number().positive().optional(),

    /**
     * Number of decimals used for UI display only.
     * Does NOT affect order validation.
     */
    displayDecimals: z.number().int().nonnegative(),

    /**
     * Default leverage shown in UI.
     * Only valid if leverageMax exists.
     */
    leverage: z.number().positive().optional(),

    /**
     * Maximum leverage allowed by the venue.
     * If undefined, leverage is not supported.
     */
    leverageMax: z.number().positive().optional(),

    /**
     * Supported margin types for this instrument.
     * Examples: ["cross", "isolated"]
     */
    supportedMarginTypes: z.array(InstrumentMarginTypeSchema).min(1),

    /**
     * Initial margin requirement (as a fraction).
     */
    initialMargin: z.number().nonnegative().optional(),

    /**
     * Maintenance margin requirement (as a fraction).
     */
    maintenanceMargin: z.number().nonnegative().optional(),

    /**
     * Expiration date for expiring derivatives.
     * ISO-8601 format.
     */
    expiryDate: z.string().datetime().optional(),

    /**
     * Settlement method for derivatives.
     * Examples: "cash", "physical"
     */
    settlementType: z.string().optional(),

    /**
     * Settlement delay after trade execution.
     * Examples: "T+0", "T+1", "T+2"
     */
    settlementDelay: SettlementDelaySchema.optional(),

    /**
     * Price multiplier applied for display or settlement.
     */
    priceMultiplier: z.number().positive().optional(),

    /**
     * Currency used for pricing the instrument.
     */
    pricingCurrency: z.string().optional(),

    /**
     * Underlying asset for derivatives.
     */
    underlyingAsset: z.string().optional(),

    /**
     * Currency used for settlement.
     */
    settlementCurrency: z.string().optional(),

    /**
     * Trading hours for non-24/7 markets.
     */
    tradingHours: TradingHoursSchema.optional(),

    /**
     * Extended trading hours (pre-market and after-hours).
     */
    extendedHours: ExtendedHoursSchema.optional(),

    /**
     * Circuit breaker configuration to prevent extreme price movements.
     */
    circuitBreaker: CircuitBreakerSchema.optional(),

    /**
     * Supported order types for this instrument.
     */
    supportedOrderTypes: z.array(OrderTypeSchema),

    /**
     * Tags for categorization and filtering.
     */
    tags: z.array(z.string()),

    /**
     * Priority for UI ranking and sorting.
     */
    priority: z.number().optional(),

    /**
     * Icon URL used in UI.
     */
    iconUrl: z.string(),

    /**
     * Highlight color for UI theming.
     */
    highlightColor: z
      .string()
      .regex(
        /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
        "Must be a valid hex color (e.g., #FF5733 or #F53)"
      ),

    /**
     * Alternative symbols or aliases.
     */
    symbol_aliases: z.array(z.string()),

    /**
     * Precomputed full-text search string.
     * symbol + symbolDisplay + description + aliases
     */
    fullTextSearch: z.string().optional(),

    /**
     * User Fee tier plan.
     */
    feeTier: z.string().optional(),

    /**
     * Maker fee percentage.
     */
    makerFee: NonNegativeDecimal,

    /**
     * Taker fee percentage.
     */
    takerFee: NonNegativeDecimal,

    /**
     * Typical bid-ask spread for informational purposes.
     * MUST NOT be used for execution.
     */
    typicalSpread: z.number().nonnegative().optional(),

    /**
     * Indicates whether the instrument is tradable.
     */
    isTradable: z.boolean(),

    /**
     * Indicates whether KYC is required to trade.
     */
    requiresKYC: z.boolean(),

    /**
     * Indicates support for futures trading.
     */
    supportsFutures: z.boolean().optional(),

    /**
     * Regulatory framework applicable to the instrument.
     */
    regulation: z.string().optional(),

    /**
     * Timezone used for trading hours and sessions.
     */
    timezone: z.string().refine(
      (tz) => {
        try {
          // Permitir UTC explícitamente (caso especial pero crítico)
          if (tz === "UTC") {
            return true;
          }
          // Validar que sea un timezone IANA válido
          // Excluir abreviaciones como PST, EST, etc.
          if (tz.length <= 3 || !tz.includes("/")) {
            return false;
          }
          Intl.DateTimeFormat(undefined, { timeZone: tz });
          return true;
        } catch {
          return false;
        }
      },
      {
        message:
          "Must be a valid IANA timezone (e.g., 'America/New_York', 'UTC', 'Europe/London')",
      }
    ),

    /**
     * Creation UNIX ms timestamp.
     */
    createdAt: z.number().int().nonnegative(),

    /**
     * Last update UNIX ms timestamp.
     */
    updatedAt: z.number().int().nonnegative(),

    /**
     * Lowercase symbol optimized for autocomplete.
     */
    symbol_lc: z.string().transform((value) => value.toLowerCase()),

    /**
     * Additional search terms for discovery.
     */
    search_terms: z.array(z.string()).optional(),

    /**
     * Supported timeframes (5m, 1h, 4h, 1d, etc)
     */
    supportedTimeframes: z.array(z.string()),

    /**
     * Supports OHLCV
     */
    supportsOHLCV: z.boolean(),

    restrictedCountries: z.array(z.string().regex(ISO_3166_1_ALPHA_2)),
  })
  .refine(
    (data) => {
      // Validar que leverage solo exista si leverageMax existe
      if (data.leverage !== undefined && data.leverageMax === undefined) {
        return false;
      }
      return true;
    },
    {
      message: "leverage can only be set if leverageMax is defined",
      path: ["leverage"],
    }
  )
  .refine(
    (data) => {
      // Validar que leverageMax sea mayor o igual que leverage
      if (
        data.leverage !== undefined &&
        data.leverageMax !== undefined &&
        data.leverage > data.leverageMax
      ) {
        return false;
      }
      return true;
    },
    {
      message: "leverage cannot exceed leverageMax",
      path: ["leverage"],
    }
  )
  .refine(
    (data) => {
      const validCountryCodes = /^[A-Z]{2}$/;
      return data.restrictedCountries.every((code) =>
        validCountryCodes.test(code)
      );
    },
    {
      message:
        "restrictedCountries must contain valid ISO 3166-1 alpha-2 codes",
      path: ["restrictedCountries"],
    }
  )

  .refine(
    (data) => {
      return data.pricePrecision === data.tickSize.decimalPlaces();
    },
    {
      message: "pricePrecision must match the tickSize decimal places",
      path: ["pricePrecision"],
    }
  )
  .refine((data) => data.minOrderValue.lte(data.maxOrderValue), {
    message: "minOrderValue must be less than or equal to maxOrderValue",
    path: ["minOrderValue"],
  })
  .superRefine((data, ctx) => {
    // 1. Leverage Consistency
    if (data.leverage !== undefined && data.leverageMax === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "leverageMax required if leverage is set",
        path: ["leverage"],
      });
    }
    if (data.leverage && data.leverageMax && data.leverage > data.leverageMax) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "leverage > leverageMax",
        path: ["leverage"],
      });
    }

    // 2. Timezone Dependency
    if (data.tradingHours && !data.timezone) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "timezone required for tradingHours",
        path: ["timezone"],
      });
    }

    // 3. Price Validation
    if (data.pricePrecision !== data.tickSize.decimalPlaces()) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "pricePrecision must match tickSize decimals",
        path: ["pricePrecision"],
      });
    }

    // 4. Quantity Model (Step vs Lot)
    const { stepSize, lotSize, quantityPrecision, minQuantity, maxQuantity } =
      data;
    if (stepSize && lotSize) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Cannot use both stepSize and lotSize",
        path: ["stepSize"],
      });
    }

    // Continuous Model Check
    if (stepSize) {
      if (quantityPrecision === undefined) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "quantityPrecision required with stepSize",
          path: ["quantityPrecision"],
        });
      } else if (quantityPrecision !== stepSize.decimalPlaces()) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "quantityPrecision mismatch with stepSize",
          path: ["quantityPrecision"],
        });
      }
      if (!minQuantity.mod(stepSize).isZero())
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "minQuantity not multiple of stepSize",
          path: ["minQuantity"],
        });

      if (!maxQuantity.mod(stepSize).isZero()) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "maxQuantity must be a multiple of stepSize",
          path: ["maxQuantity"],
        });
      }
    }

    // Discrete Model Check
    if (lotSize) {
      if (quantityPrecision !== undefined)
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "lotSize cannot have quantityPrecision",
          path: ["quantityPrecision"],
        });
      if (!minQuantity.mod(lotSize).isZero())
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "minQuantity not multiple of lotSize",
          path: ["minQuantity"],
        });

      if (!maxQuantity.mod(lotSize).isZero()) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "maxQuantity must be a multiple of lotSize",
          path: ["maxQuantity"],
        });
      }
    }

    // Order Value Check
    if (data.minOrderValue.gt(data.maxOrderValue)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "minOrderValue > maxOrderValue",
        path: ["minOrderValue"],
      });
    }

    if (data.tradingHours) {
      data.tradingHours.sessions.forEach((session, index) => {
        const [openH, openM] = session.open.split(":").map(Number);
        const [closeH, closeM] = session.close.split(":").map(Number);

        const openTotalMinutes = openH * 60 + openM;
        const closeTotalMinutes = closeH * 60 + closeM;

        if (closeTotalMinutes <= openTotalMinutes) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: `Session ${index}: Close time (${session.close}) must be after open time (${session.open})`,
            path: ["tradingHours", "sessions", index],
          });
        }
      });
    }
  })
  .readonly();

/**
 * ============================================================
 * QUANTITY MODEL — LOGICAL MATRIX (FINAL)
 * ============================================================
 *
 * This matrix defines the EXECUTION-VALID states for the instrument.
 * Any violation of these states is caught by the superRefine block.
 *
 * | stepSize | lotSize | qtyPrecision | Model / Validity                     |
 * |--------- |-------- |------------- |--------------------------------------|
 * | defined  | none    | defined      | Continuous (e.g. Crypto, Forex)      |
 * | defined  | none    | none         | INVALID – precision required         |
 * | none     | defined | none         | Discrete (e.g. Stocks, Options)     |
 * | none     | defined | defined      | INVALID – lots are discrete          |
 * | defined  | defined | any          | INVALID – stepSize vs lotSize clash  |
 * | none     | none    | none         | Provider / Venue controlled          |
 * | none     | none    | defined      | INVALID – precision needs stepSize   |
 *
 * ------------------------------------------------------------
 * HARD INVARIANTS (ENFORCED BY SCHEMA)
 * ------------------------------------------------------------
 *
 * 1. Mutual Exclusivity: (stepSize XOR lotSize)
 * - An instrument cannot be both continuous and discrete.
 *
 * 2. Precision Symmetry: (stepSize <==> quantityPrecision)
 * - quantityPrecision MUST exist if and only if stepSize exists.
 *
 * 3. Mathematical Consistency:
 * - quantityPrecision === decimals(stepSize)
 * - This ensures valid arithmetic for order rounding.
 *
 * 4. Incremental Alignment:
 * - minQuantity % increment == 0 (where increment is stepSize OR lotSize)
 * - maxQuantity % increment == 0
 *
 * ------------------------------------------------------------
 * DOMAIN EXAMPLES
 * ------------------------------------------------------------
 * - Continuous: BTC/USDT (stepSize: 0.00001, precision: 5)
 * - Discrete:   AAPL Equity (lotSize: 1, precision: undefined)
 * - Derivative: SPY Option  (lotSize: 100, precision: undefined)
 * ============================================================
 */
