import { z } from "zod";

export const InstrumentStatusSchema = z.enum([
  "active",
  "inactive",
  "delisted",
  "halted",
]);

export const InstrumentTypeSchema = z.enum([
  "spot",
  "futures",
  "options",
  "other",
]);

export const InstrumentMarginTypeSchema = z.enum(["cross", "isolated"]);

export const InstrumentMarketSchema = z.enum([
  "crypto",
  "stocks",
  "forex",
  "futures",
  "options",
  "indices",
  "commodities",
  "bonds",
  "etfs",
  "cfds",
  "funds",
  "rates",
  "synthetic",
  "other",
]);

export const SettlementDelaySchema = z.enum(["T+0", "T+1", "T+2"]);

export type InstrumentStatus = z.infer<typeof InstrumentStatusSchema>;
export type InstrumentType = z.infer<typeof InstrumentTypeSchema>;
export type InstrumentMarginType = z.infer<typeof InstrumentMarginTypeSchema>;
export type InstrumentMarket = z.infer<typeof InstrumentMarketSchema>;
export type SettlementDelay = z.infer<typeof SettlementDelaySchema>;

export const TradingHoursSchema = z.object({
  /** HH:mm format */
  open: z.string().regex(/^\d{2}:\d{2}$/, "Must be in HH:mm format"),
  /** HH:mm format */
  close: z.string().regex(/^\d{2}:\d{2}$/, "Must be in HH:mm format"),
  /** 0 (Sunday) - 6 (Saturday) */
  days: z.array(z.number().int().min(0).max(6)),
});

export type TradingHours = z.infer<typeof TradingHoursSchema>;

// ============================================
// INSTRUMENT SCHEMA
// ============================================

export const InstrumentSchema = z
  .object({
    /**
     * Database primary key.
     * UUID v7 generated by Postgres.
     * Immutable.
     */
    id: z.string().uuid(),

    /**
     * Internal business identifier.
     * Stable across systems (DB, search, cache, logs).
     * Example: "binance-btc-usdt"
     */
    internalId: z.string().min(1),

    /**
     * Idempotent identifier used by search engines (Typesense, Meilisearch).
     * Must be deterministic and unique.
     */
    idempotentId: z.string().min(1),

    /**
     * Trading symbol as defined by the venue or market.
     * Examples: "BTCUSDT", "AAPL", "EURUSD"
     */
    symbol: z.string().min(1),

    /**
     * Human-friendly symbol for UI display.
     * Example: "BTC/USDT"
     */
    symbolDisplay: z.string().min(1),

    /**
     * Descriptive instrument name.
     * Example: "Bitcoin / Tether USD"
     */
    description: z.string().min(1),

    /**
     * Base asset of the instrument.
     * What is being bought or sold.
     * Example: "BTC"
     */
    base: z.string().min(1),

    /**
     * Quote asset of the instrument.
     * What the price is denominated in.
     * Example: "USDT"
     */
    quote: z.string().min(1),

    /**
     * Exchange, broker, or venue name.
     * Example: "Binance", "NASDAQ", "CME"
     */
    exchange: z.string().min(1),

    /**
     * Country or jurisdiction where the exchange operates.
     * Example: "US", "JP", "SG"
     */
    exchangeCountry: z.string().min(1),

    /**
     * Market category.
     * Examples: "crypto", "stocks", "forex", "futures"
     */
    market: InstrumentMarketSchema,

    /**
     * Instrument type.
     * Examples: "spot", "futures", "options", "other"
     */
    type: InstrumentTypeSchema,

    /**
     * Name of the data or execution provider.
     * Example: "Binance", "Bloomberg", "InteractiveBrokers"
     */
    providerName: z.string().min(1),

    /**
     * Provider-specific instrument identifier.
     * Unique within the provider.
     */
    providerId: z.string().min(1),

    /**
     * Provider-specific trading symbol.
     */
    providerSymbol: z.string().min(1),

    /**
     * Instrument lifecycle status.
     * Examples: "active", "inactive", "delisted"
     */
    status: InstrumentStatusSchema,

    /**
     * Whether the instrument is hidden from search and UI.
     */
    isHidden: z.boolean(),

    /**
     * Indicates synthetic or derived instruments
     * (indexes, baskets, internal products).
     */
    isSynthetic: z.boolean(),

    /**
     * International Securities Identification Number (if applicable).
     */
    isin: z.string().optional(),

    /**
     * Committee on Uniform Securities Identification Procedures code.
     */
    cusip: z.string().optional(),

    /**
     * Minimum allowed price increment.
     * Prices must be multiples of this value.
     */
    tickSize: z.number().positive(),

    /**
     * Quantity step size.
     * Defines the minimum increment for quantity.
     * Mutually exclusive with lotSize.
     */
    stepSize: z.number().positive().optional(),

    /**
     * Maximum number of decimal places allowed in price.
     * Must be consistent with tickSize.
     *
     * pricePrecision === decimals(tickSize)
     */
    pricePrecision: z.number().int().nonnegative(),

    /**
     * Maximum number of decimal places allowed in quantity.
     * Only valid when stepSize is used.
     */
    quantityPrecision: z.number().int().nonnegative().optional(),

    /**
     * Minimum quantity allowed per order.
     */
    minQuantity: z.number().nonnegative(),

    /**
     * Maximum quantity allowed per order.
     */
    maxQuantity: z.number().positive(),

    /**
     * Minimum notional value required to place an order.
     * notional = price × quantity
     */
    minOrderValue: z.number().nonnegative(),

    /**
     * Maximum notional value allowed per order.
     */
    maxOrderValue: z.number().positive(),

    /**
     * Fixed lot size for instruments traded in whole lots.
     * Mutually exclusive with stepSize and quantityPrecision.
     */
    lotSize: z.number().positive().optional(),

    /**
     * Contract size for derivatives.
     * Represents how much underlying one contract controls.
     */
    contractSize: z.number().positive().optional(),

    /**
     * Number of decimals used for UI display only.
     * Does NOT affect order validation.
     */
    displayDecimals: z.number().int().nonnegative(),

    /**
     * Default leverage shown in UI.
     * Only valid if leverageMax exists.
     */
    leverage: z.number().positive().optional(),

    /**
     * Maximum leverage allowed by the venue.
     * If undefined, leverage is not supported.
     */
    leverageMax: z.number().positive().optional(),

    /**
     * Supported margin types for this instrument.
     * Examples: ["cross", "isolated"]
     */
    supportedMarginTypes: z.array(InstrumentMarginTypeSchema),

    /**
     * Initial margin requirement (as a fraction).
     */
    initialMargin: z.number().nonnegative().optional(),

    /**
     * Maintenance margin requirement (as a fraction).
     */
    maintenanceMargin: z.number().nonnegative().optional(),

    /**
     * Expiration date for expiring derivatives.
     * ISO-8601 format.
     */
    expiryDate: z.string().datetime().optional(),

    /**
     * Settlement method for derivatives.
     * Examples: "cash", "physical"
     */
    settlementType: z.string().optional(),

    /**
     * Settlement delay after trade execution.
     * Examples: "T+0", "T+1", "T+2"
     */
    settlementDelay: SettlementDelaySchema.optional(),

    /**
     * Price multiplier applied for display or settlement.
     */
    priceMultiplier: z.number().optional(),

    /**
     * Currency used for pricing the instrument.
     */
    pricingCurrency: z.string().optional(),

    /**
     * Underlying asset for derivatives.
     */
    underlyingAsset: z.string().optional(),

    /**
     * Currency used for settlement.
     */
    settlementCurrency: z.string().optional(),

    /**
     * Trading hours for non-24/7 markets.
     */
    tradingHours: TradingHoursSchema.optional(),

    /**
     * Tags for categorization and filtering.
     */
    tags: z.array(z.string()),

    /**
     * Priority for UI ranking and sorting.
     */
    priority: z.number().optional(),

    /**
     * Icon URL used in UI.
     */
    iconUrl: z.string(),

    /**
     * Highlight color for UI theming.
     */
    highlightColor: z
      .string()
      .regex(
        /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
        "Must be a valid hex color (e.g., #FF5733 or #F53)"
      ),

    /**
     * Alternative symbols or aliases.
     */
    symbol_aliases: z.array(z.string()),

    /**
     * Precomputed full-text search string.
     * symbol + symbolDisplay + description + aliases
     */
    fullTextSearch: z.string().optional(),

    /**
     * User Fee tier plan.
     */
    feeTier: z.string().optional(),

    /**
     * Maker fee percentage.
     */
    makerFee: z.number().nonnegative().optional(),

    /**
     * Taker fee percentage.
     */
    takerFee: z.number().nonnegative().optional(),

    /**
     * Typical bid-ask spread for informational purposes.
     * MUST NOT be used for execution.
     */
    typicalSpread: z.number().nonnegative().optional(),

    /**
     * Indicates whether the instrument is tradable.
     */
    isTradable: z.boolean().optional(),

    /**
     * Indicates whether margin trading is allowed.
     */
    isMarginAllowed: z.boolean().optional(),

    /**
     * Indicates whether KYC is required to trade.
     */
    requiresKYC: z.boolean().optional(),

    /**
     * Indicates support for stop-limit orders.
     */
    supportsStopLimit: z.boolean().optional(),

    /**
     * Indicates support for margin trading.
     */
    supportsMarginTrading: z.boolean().optional(),

    /**
     * Indicates support for futures trading.
     */
    supportsFutures: z.boolean().optional(),

    /**
     * Regulatory framework applicable to the instrument.
     */
    regulation: z.string().optional(),

    /**
     * Timezone used for trading hours and sessions.
     */
    timezone: z.string().refine(
      (tz) => {
        try {
          // Permitir UTC explícitamente (caso especial pero crítico)
          if (tz === "UTC") {
            return true;
          }
          // Validar que sea un timezone IANA válido
          // Excluir abreviaciones como PST, EST, etc.
          if (tz.length <= 3 || !tz.includes("/")) {
            return false;
          }
          Intl.DateTimeFormat(undefined, { timeZone: tz });
          return true;
        } catch {
          return false;
        }
      },
      {
        message:
          "Must be a valid IANA timezone (e.g., 'America/New_York', 'UTC', 'Europe/London')",
      }
    ),

    /**
     * Creation UNIX ms timestamp.
     */
    createdAt: z.number().int().nonnegative(),

    /**
     * Last update UNIX ms timestamp.
     */
    updatedAt: z.number().int().nonnegative(),

    /**
     * Lowercase symbol optimized for autocomplete.
     */
    symbol_lc: z.string().optional(),

    /**
     * Additional search terms for discovery.
     */
    search_terms: z.array(z.string()).optional(),

    /**
     * Supported timeframes (5m, 1h, 4h, 1d, etc)
     */
    supportedTimeframes: z.array(z.string()),

    /**
     * Supports OHLCV
     */
    supportsOHLCV: z.literal(true),
  })
  .refine(
    (data) => {
      // Validar que stepSize y lotSize sean mutuamente exclusivos
      if (data.stepSize !== undefined && data.lotSize !== undefined) {
        return false;
      }
      return true;
    },
    {
      message:
        "stepSize and lotSize are mutually exclusive - only one can be defined",
      path: ["stepSize"],
    }
  )
  .refine(
    (data) => {
      // Validar que leverage solo exista si leverageMax existe
      if (data.leverage !== undefined && data.leverageMax === undefined) {
        return false;
      }
      return true;
    },
    {
      message: "leverage can only be set if leverageMax is defined",
      path: ["leverage"],
    }
  )
  .refine(
    (data) => {
      // Validar que leverageMax sea mayor o igual que leverage
      if (
        data.leverage !== undefined &&
        data.leverageMax !== undefined &&
        data.leverage > data.leverageMax
      ) {
        return false;
      }
      return true;
    },
    {
      message: "leverage cannot exceed leverageMax",
      path: ["leverage"],
    }
  )
  .refine(
    (data) => {
      // Validar consistencia entre tickSize y pricePrecision
      // pricePrecision debe ser igual al número de decimales de tickSize
      const tickSizeStr = data.tickSize.toString();
      const decimalPart = tickSizeStr.split(".")[1];
      const expectedPrecision = decimalPart ? decimalPart.length : 0;

      // Si tickSize es 0.01, pricePrecision debe ser 2
      // Si tickSize es 0.001, pricePrecision debe ser 3
      // Si tickSize es 1, pricePrecision debe ser 0
      if (data.pricePrecision !== expectedPrecision) {
        return false;
      }
      return true;
    },
    {
      message:
        "pricePrecision must match the number of decimal places in tickSize",
      path: ["pricePrecision"],
    }
  );
