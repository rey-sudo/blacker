import { z } from "zod";
import {
  DecimalSchema,
  InstrumentMarginTypeSchema,
  InstrumentMarketSchema,
  InstrumentOrderTypeSchema,
  InstrumentStatusSchema,
  InstrumentTypeSchema,
} from "./index.js";

/* ──────────────────────────────────────────────────────────
 * InstrumentCryptoSpotSchema
 * ────────────────────────────────────────────────────────── */
export const InstrumentCryptoSpotSchema = z
  .object({
    /**
     * Database primary key.
     * UUID v7 generated by Postgres.
     * Immutable.
     */
    id: z.string().uuid(),

    /**
     * Internal business identifier.
     * Stable across systems (DB, search, cache, logs).
     * Example: "binance-btc-usdt"
     */
    internalId: z.string().min(1),

    /**
     * Idempotent identifier used by search engines (Typesense, Meilisearch).
     * Must be deterministic and unique.
     */
    idempotentId: z.string().min(1),

    type: InstrumentTypeSchema,

    /**
     * Market category.
     * Examples: "crypto", "stocks", "forex", "futures"
     */
    market: InstrumentMarketSchema,

    symbol: z.string().transform((v) => v.toUpperCase()),

    /**
     * Human-friendly symbol for UI display.
     * Example: "BTC/USDT"
     */
    symbolDisplay: z.string().min(1),

    /**
     * Descriptive instrument name.
     * Example: "Bitcoin / Tether USD"
     */
    description: z.string().min(1),

    baseAsset: z
      .string()
      .min(2)
      .max(10)
      .transform((v) => v.toUpperCase()),

    quoteAsset: z
      .string()
      .min(2)
      .max(10)
      .transform((v) => v.toUpperCase()),

    /* Crypto-specific */
    priceIncrement: DecimalSchema.refine((v) => v.gt(0), {
      message: "priceIncrement debe ser mayor que 0",
    }),

    quantityIncrement: DecimalSchema.refine((v) => v.gt(0), {
      message: "quantityIncrement debe ser mayor que 0",
    }),

    minQuantity: DecimalSchema.refine((v) => v.gt(0), {
      message: "minQuantity debe ser mayor que 0",
    }),

    maxQuantity: DecimalSchema.refine((v) => v.gt(0), {
      message: "maxQuantity debe ser mayor que 0",
    }),

    spread: DecimalSchema.refine((v) => v.gte(0), {
      message: "spread no puede ser negativo",
    }),

    /**
     * Minimum price increment (tick size) for the instrument.
     * All prices must be multiples of this value.
     * Example: 0.01 USDT for BTC/USDT.
     */
    tickSize: z.number().positive(),

    /**
     * Maximum number of decimal places allowed in price.
     * Must match the number of decimals in tickSize.
     * Example: tickSize 0.01 → pricePrecision 2
     */
    pricePrecision: z.number().int().nonnegative(),

    /**
     * Minimum quantity increment per order.
     * Mutually exclusive with lotSize.
     */
    stepSize: z.number().positive().optional(),

    /**
     * Maximum number of decimal places allowed in quantity.
     * Only relevant if stepSize is used.
     */
    quantityPrecision: z.number().int().nonnegative().optional(),

    /**
     * Fixed lot size for contracts.
     * Mutually exclusive with stepSize.
     */
    lotSize: z.number().positive().optional(),

    /**
     * Contract size for derivatives.
     * Determines how much underlying one CFD contract controls.
     */
    contractSize: z.number().positive().optional(),

    /**
     * Name of the data or execution provider.
     * Example: "Binance", "Bloomberg", "InteractiveBrokers"
     */
    providerName: z.string().min(1),

    /**
     * Provider-specific instrument identifier.
     * Unique within the provider.
     */
    providerId: z.string().min(1),

    /**
     * Provider-specific trading symbol.
     */
    providerSymbol: z.string().min(1),

    /**
     * Instrument lifecycle status.
     * Examples: "active", "inactive", "delisted"
     */
    status: InstrumentStatusSchema,

    /**
     * Whether the instrument is hidden from search and UI.
     */
    isHidden: z.boolean(),

    /**
     * Default leverage shown in UI.
     * Only valid if leverageMax exists.
     */
    leverage: z.number().positive().optional(),

    /**
     * Maximum leverage allowed by the venue.
     * If undefined, leverage is not supported.
     */
    leverageMax: z.number().positive().optional(),

    supportedMarginTypes: z.array(InstrumentMarginTypeSchema),

    /**
     * Supported order types for this instrument.
     */
    supportedOrderTypes: z.array(InstrumentOrderTypeSchema),

    /**
     * Initial margin requirement as a fraction of the position notional.
     * Example: 0.1 → 10% of the position value must be deposited to open the trade.
     * Only relevant for leveraged instruments (CFD, futures).
     */
    initialMargin: z.number().nonnegative().optional(),

    /**
     * Maintenance margin requirement as a fraction of the position notional.
     * Example: 0.05 → 5% of the position value must remain as collateral to avoid liquidation.
     * Only relevant for leveraged instruments (CFD, futures).
     */
    maintenanceMargin: z.number().nonnegative().optional(),

    /**
     * Tags for categorization and filtering.
     */
    tags: z.array(z.string()),

    /**
     * Icon URL used in UI.
     */
    iconUrl: z.string(),

    /**
     * Precomputed full-text search string.
     * symbol + symbolDisplay + description + aliases
     */
    fullTextSearch: z.string().optional(),

    /**
     * Indicates whether the instrument is tradable.
     */
    isTradable: z.boolean().optional(),

    /**
     * Supported timeframes (5m, 1h, 4h, 1d, etc)
     */
    supportedTimeframes: z.array(z.string()),

    supportsOHLCV: z.boolean(),

    /**
     * Blockchain network where the token resides.
     * Examples: "Ethereum", "Binance Smart Chain", "Solana".
     * Critical for deposits, withdrawals, and transaction routing.
     */
    network: z.string(),

    /**
     * Smart contract address for token instruments (ERC-20, BEP-20, etc.).
     * Optional for native coins like BTC or ETH.
     */
    contractAddress: z.string().optional(),

    /**
     * Number of decimal places used by the token.
     * Determines precision for trading, balances, and UI display.
     */
    decimals: z.number().int().nonnegative(),

    /**
     * Indicates if the token is a stablecoin.
     * Useful for pricing logic, margin calculations, and risk rules.
     */
    isStablecoin: z.boolean().optional(),

    /**
     * Minimum trade amount expressed in USD equivalent.
     * Ensures trades comply with platform and risk constraints.
     */
    minTradeAmountUSD: z.number().nonnegative().optional(),

    /**
     * Maximum trade amount expressed in USD equivalent.
     * Limits exposure per order for risk management.
     */
    maxTradeAmountUSD: z.number().nonnegative().optional(),

    /**
     * Indicates if withdrawals are currently allowed for this instrument.
     * Useful during maintenance or network congestion.
     */
    withdrawalEnabled: z.boolean().optional(),

    /**
     * Indicates if deposits are currently allowed for this instrument.
     * Useful during maintenance or network congestion.
     */
    depositEnabled: z.boolean().optional(),

    /**
     * Type of wallet used for this instrument in the exchange.
     * "hot" for online wallets, "cold" for offline storage.
     */
    walletType: z.enum(["hot", "cold"]).optional(),

    /**
     * Name of the external price feed provider.
     * Important for derivatives, funding rate calculations, and UI display.
     */
    priceFeedProvider: z.string().optional(),

    /**
     * Periodic funding rate for perpetual futures or margin products.
     * Expressed as a fraction (e.g., 0.0001 = 0.01%).
     */
    fundingRate: z.number().optional(),

    /**
     * Unix timestamp (ms) for the next funding event.
     * Relevant for perpetual futures with recurring funding payments.
     */
    nextFundingTime: z.number().int().nonnegative().optional(),

    /**
     * Indicates if derivatives (futures, options) can be created on this instrument.
     * Useful for risk engine, product offerings, and UI logic.
     */
    isDerivable: z.boolean().optional(),

    createdAt: z.number(),

    updatedAt: z.number().optional(),
  })
  .superRefine((data, ctx) => {
    const {
      symbol,
      baseAsset,
      quoteAsset,
      priceIncrement,
      quantityIncrement,
      minQuantity,
      maxQuantity,
      spread,
    } = data;

    /* 1️⃣ base / quote distintos */
    if (baseAsset === quoteAsset) {
      ctx.addIssue({
        path: ["baseAsset"],
        message: "baseAsset y quoteAsset no pueden ser iguales",
        code: z.ZodIssueCode.custom,
      });
    }

    /* 2️⃣ symbol coherente */
    const expectedSymbol = `${baseAsset}/${quoteAsset}`;
    if (symbol !== expectedSymbol) {
      ctx.addIssue({
        path: ["symbol"],
        message: `symbol debe ser ${expectedSymbol}`,
        code: z.ZodIssueCode.custom,
      });
    }

    /* 3️⃣ formato estándar */
    if (!/^[A-Z0-9]{2,10}\/[A-Z0-9]{2,10}$/.test(symbol)) {
      ctx.addIssue({
        path: ["symbol"],
        message: "Formato inválido (ej: BTC/USDT)",
        code: z.ZodIssueCode.custom,
      });
    }

    /* 4️⃣ cantidades coherentes */
    if (minQuantity.gt(maxQuantity)) {
      ctx.addIssue({
        path: ["minQuantity"],
        message: "minQuantity no puede ser mayor que maxQuantity",
        code: z.ZodIssueCode.custom,
      });
    }

    /* 5️⃣ precisión coherente con incrementos */
    if (!minQuantity.mod(quantityIncrement).eq(0)) {
      ctx.addIssue({
        path: ["minQuantity"],
        message: "minQuantity debe ser múltiplo de quantityIncrement",
        code: z.ZodIssueCode.custom,
      });
    }

    if (!maxQuantity.mod(quantityIncrement).eq(0)) {
      ctx.addIssue({
        path: ["maxQuantity"],
        message: "maxQuantity debe ser múltiplo de quantityIncrement",
        code: z.ZodIssueCode.custom,
      });
    }

    /* 6️⃣ spread lógico */
    if (spread.gt(0) && spread.lt(priceIncrement)) {
      ctx.addIssue({
        path: ["spread"],
        message: "spread no puede ser menor que priceIncrement",
        code: z.ZodIssueCode.custom,
      });
    }

    if (spread.gt(priceIncrement.mul(1_000))) {
      ctx.addIssue({
        path: ["spread"],
        message: "spread excesivamente alto para un par crypto spot",
        code: z.ZodIssueCode.custom,
      });
    }
  });

/* ──────────────────────────────────────────────────────────
 * Tipo inferido
 * ────────────────────────────────────────────────────────── */
export type InstrumentCryptoSpot = z.infer<typeof InstrumentCryptoSpotSchema>;
